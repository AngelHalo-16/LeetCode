/* 
https://leetcode-cn.com/problems/walking-robot-simulation/

机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令：
-2：向左转 90 度
-1：向右转 90 度
1 <= x <= 9：向前移动 x 个单位长度
在网格上有一些格子被视为障碍物。
第 i 个障碍物位于网格点  (obstacles[i][0], obstacles[i][1])
机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。
返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。

示例 1：
输入: commands = [4,-1,3], obstacles = []
输出: 25
解释: 机器人将会到达 (3, 4)

示例 2：
输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
输出: 65
解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处
*/

/**
 * @param {number[]} commands
 * @param {number[][]} obstacles
 * @return {number}
 */

 // 计算机器人每一步的（x，y）和距离
 // 数据特别大时出现错误（尚未找到错误）
{
    let robotSim = function(commands, obstacles) {
        if (commands.length < 1) return 0
    
        const obstaclesStr = obstacles.map(item => item.join(''))
        let maxL = 0
        let robotPos = [0, 0]
        let robotDir = 0
    
        for (let i = 0; i < commands.length; i++) {
            // 变方向的判断
            if (commands[i] === -1) {
                robotDir += 1
            } else if (commands[i] === -2) {
                robotDir -= 1
            } else {
                // 行走的判断
                for (let j = 0; j < commands[i]; j++) {
                    // 注意数组的浅拷贝和深拷贝
                    let robotNextPos = robotPos.slice()
                    // robotDir % 4 为 [0，1，2，3] or [-0，-3，-2，-1] 分别表示机器人的朝向是 [y+，x+，y-，x-]
                    if (robotDir % 4 === 0 || robotDir % 4 === -0) {
                        robotNextPos[1] += 1
                    } else if (robotDir % 4 === 1 || robotDir % 4 === -3) {
                        robotNextPos[0] += 1
                    } else if (robotDir % 4 === 2 || robotDir % 4 === -2) {
                        robotNextPos[1] -= 1
                    } else if (robotDir % 4 === 3 || robotDir % 4 === -1) {
                        robotNextPos[0] -= 1
                    }
                    
                    // 预判断机器人的下一步有没有障碍物
                    if (obstaclesStr.includes(robotNextPos.join(''))) {
                        break
                    } else {
                        robotPos = robotNextPos.slice()
                        maxL = Math.max(maxL, robotPos[0] * robotPos[0] + robotPos[1] * robotPos[1])
                    }
                }
            }
        }
    
        return maxL
    };
}

// 构建雷达图，以满足机器人在任意位置都能够通过其坐标得出移动轴上的所有障碍位置
// 机器人移动之前先确认移动方向
// 根据机器人当前坐标在雷达图里找到移动轴上存在的障碍，并对其进行分析，得到本次移动最终的目标
// 执行移动（赋值终点坐标）后，进行跟原点直线距离的测量 
var robotSim = function (commands, obstacles) {
    // 构建障碍缓存（雷达图），根据移动特性，我们根据x,y轴值分别进行缓存
    const obsCacheByX = new Map(); // x轴方向上的障碍坐标
    const obsCacheByY = new Map(); // y轴方向上的障碍坐标
    obstacles.forEach(o => {
      obsCacheByX.has(o[0]) ? obsCacheByX.get(o[0]).push(o[1]) : obsCacheByX.set(o[0], [o[1]]);
      obsCacheByY.has(o[1]) ? obsCacheByY.get(o[1]).push(o[0]) : obsCacheByY.set(o[1], [o[0]]);
    });
    const obsCaches = [obsCacheByX, obsCacheByY];
    // 移动方向集合分别代表上，右，下，左，其中[a,b]，a是移动轴坐标索引，b是移动方向
    const heads = [[1, 1], [0, 1], [1, -1], [0, -1]]; // n, e, s, w; [x|y, +|-]
    const coord = [0, 0, 0]; // x, y, head，坐标信息，包括x, y，以及当前移动方向索引
    let max = 0;
    let right = 0; // 记录向右转的次数，负数代表向左转
    // 移动函数
    const go = function (c) {
        if (right !== 0) { // 移动之前，检测是否需要转向
          // 设置方向索引
          // 因为每一次向右转其实就是当前索引+1，超过之后就%4，因为原地转4次就是复位
          // 而一次向左转可以理解成向右转三次，结合一起有：
          coord[2] = (coord[2] + (right < 0 ? 3 * -right : right)) % 4;
          // 执行转向后，将转向指令清零
          right = 0;
        }
        // 获取当前方向设定
        const head = heads[coord[2]];
        // 移动轴索引
        const moveAxis = head[0];
        // 固定轴索引，因为每次只会朝单一方向移动，因此不是x轴就是y轴，因此：
        const standAxis = (moveAxis + 1) % 2;
        // 计算无障碍时的预期终点
        let end = coord[moveAxis] + c * head[1];
        // 从缓存中找出当前移动方向轴上的障碍坐标
        const obVals = obsCaches[standAxis].get(coord[standAxis]) || [];
        // 碰撞可能性检测（雷达在此）
        //  有效障碍需要满足介于end与当前出发点之前，这里有两种情况:
        //           end <---- o ----- coord ---- o ------> end
        //  head[1]            -1        |        +1
        //  可以归纳出：
        //  (head[1] === 1 && coord[moveAxis] < o && end >= o) ||
        //  (head[1] === -1 && coord[moveAxis] > o && end <= o)
        //  约简为：
        //  const detector = head[1] === 1 ? Math.max : Math.min;
        //  const coordRef = coord[moveAxis] + head[1]; // 这里是为了让detector能区分非等情况
        //  detector(coordRef, o) === o && detector(o, end) === end
        const detector = head[1] === 1 ? Math.max : Math.min;
        const coordRef = coord[moveAxis] + head[1];
        obVals.forEach(o => {
          if (detector(coordRef, o) === o && detector(o, end) === end) {
            // 满足条件时，将当前终点坐标设置在障碍之前
            end = o - head[1];
          }
        });
        // 设置坐标终点
        coord[moveAxis] = end;
        // 求当前坐标距离原点(0,0)欧式距离的平方，并与之前的值比较，取其最大值
        max = Math.max(max, coord[0] * coord[0] + coord[1] * coord[1]);
    }
    commands.forEach(c => {
        if (c >= 0) {
          // 接收到步长时，开始移动机器人
          go(c);
        } else {
          // 转向可以先记录（有时候若干相邻的转向指令可以相互抵消）
          right += (c === -1 ? 1 : -1);
        }
    });
    return max;
}

const arr1 = [9,8,4,8,1,6,3,-2,-2,-1,4,6,3,-1,5,3,8,6,2,5,-2,7,8,-2,4,5,2,7,3,4,8,6,5,6,6,-1,-1,-1,6,9,-1,-2,-2,2,3,-1,5,5,-1,-1,1,8,-1,1,-1,1,6,2,-1,6,4,7,3,6,7,-2,9,8,-1,4,-2,6,1,3,5,5,6,-1,6,-2,-1,-1,-2,-2,6,3,-1,-2,7,1,7,3,2,7,4,7,4,8,-1,1]
const arr2 = [[97,-2],[-65,69],[0,-19],[99,96],[-89,-97],[82,50],[-88,-5],[-83,17],[-85,-6],[15,58],[-89,86],[12,41],[-84,2],[-92,-45],[-96,4],[-14,29],[-94,76],[40,-89],[75,-29],[-96,-83],[-99,-79],[-2,88],[-55,30],[-94,-11],[42,83],[99,-5],[15,92],[-38,-49],[61,-50],[52,97],[97,-31],[-64,-65],[-1,-25],[-46,97],[75,-74],[60,-74],[-15,2],[-88,-61],[-16,-31],[-100,74],[29,-98],[-79,-57],[-47,-94],[-38,-40],[-92,-39],[15,96],[-28,86],[78,94],[-1,19],[-70,54],[54,-40],[-10,43],[-32,9],[13,36],[55,-51],[-93,45],[57,57],[78,13],[74,-7],[-45,-29],[-45,-76],[-2,6],[28,49],[79,8],[-81,-52],[-67,-41],[-7,-43],[-60,29],[8,39],[48,-10],[35,-8],[-84,4],[0,32],[43,91],[37,89],[-60,34],[92,77],[61,-63],[-92,24],[-41,65],[77,-65],[74,99],[0,26],[-31,-57],[40,94],[-78,-10],[-89,-37],[-19,25],[-62,27],[-83,53],[69,-43],[-21,13],[-90,-90],[86,20],[63,43],[81,73],[-9,-100],[62,62],[16,10],[34,-38],[-89,-57],[74,49],[42,-44],[18,97],[-80,-58],[17,61],[42,51],[-57,-64],[-80,36],[-60,57],[25,62],[-42,20],[-100,95],[7,-24],[-98,84],[49,83],[-83,42],[9,97],[39,-7],[-100,9],[-39,-38],[-15,10],[84,-93],[16,85],[-35,82],[-92,14],[86,5],[32,-100],[-23,-35],[-80,-32],[-1,26],[-68,52],[-5,-59],[63,-28],[26,-65],[-42,9],[36,42],[-9,-18],[19,96],[19,-99],[66,94],[18,-53],[49,100],[8,-14],[-1,9],[-81,56],[96,-94],[6,30],[71,39],[71,-73],[41,-9],[-91,93],[99,-59],[-56,-64],[32,-16],[-8,56],[-27,2],[-31,89],[98,49],[0,-86],[86,95],[-52,66],[9,26],[89,-51],[-77,-22],[34,-32],[-22,-41],[40,-72],[-61,62],[22,-62],[72,91],[81,-33],[-25,60],[20,64],[93,100],[73,22],[-39,57],[55,51],[-12,-49],[-84,99],[-59,39],[23,86],[-53,-100],[-12,-31],[-20,65],[-98,-39],[69,59],[-33,-32],[63,26],[-90,27],[33,71],[37,88],[-73,-47],[2,35],[57,-88],[-83,46],[92,76],[-29,10],[-73,51],[4,-22]]
console.log(robotSim(arr1, arr2)) // 11401